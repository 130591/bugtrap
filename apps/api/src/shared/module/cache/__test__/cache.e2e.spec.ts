import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { EventEmitterModule } from '@nestjs/event-emitter';
import * as request from 'supertest';
import { CacheModule } from '../cache.module';
import { CacheService } from '../core/cache-service';
import { ConsistentCacheInterceptor } from '../interceptors/cache.interceptor';
;
// Controller de teste;
import { Controller, Get, Post, Body, Param, UseInterceptors } from '@nestjs/common';
;
@Controller('test');
@UseInterceptors(ConsistentCacheInterceptor);
class TestController {;
  constructor(private readonly cacheService: CacheService) {};
;
  @Get('users/:id');
  async getUser(@Param('id') id: string) {;
    return this.cacheService.getOrSet(;
      `user:${id}`,;
      async () => ({ id, name: `User ${id}`, fetchedAt: Date.now() }),;
      { ttl: 60, tags: ['user'] };
    );
  };
;
  @Post('users/:id');
  async updateUser(@Param('id') id: string, @Body() data: any) {;
    await this.cacheService.invalidateByTags(['user']);
    return { id, ...data, updatedAt: Date.now() };
  };
};
;
describe('Cache E2E Tests', () => {;
  let app: INestApplication;
  let cacheService: CacheService;
;
  beforeAll(async () => {;
    const moduleFixture: TestingModule = await Test.createTestingModule({;
      imports: [;
        ConfigModule.forRoot({;
          envFilePath: '.env.test',;
        }),;
        EventEmitterModule.forRoot(),;
        CacheModule,;
      ],;
      controllers: [TestController],;
    }).compile();
;
    app = moduleFixture.createNestApplication();
    cacheService = moduleFixture.get<CacheService>(CacheService);
    ;
    await app.init();
  });
;
  afterAll(async () => {;
    await app.close();
  });
;
  beforeEach(async () => {;
    await cacheService.clear(true);
  });
;
  it('should cache GET requests automatically', async () => {;
    const response1 = await request(app.getHttpServer());
      .get('/test/users/123');
      .expect(200);
;
    const response2 = await request(app.getHttpServer());
      .get('/test/users/123');
      .expect(200);
;
    // Deve retornar os mesmos dados (mesmo timestamp);
    expect(response1.body.fetchedAt).toBe(response2.body.fetchedAt);
  });
;
  it('should invalidate cache on POST requests', async () => {;
    // Primeira requisição - popula cache;
    const response1 = await request(app.getHttpServer());
      .get('/test/users/123');
      .expect(200);
;
    // Update user - deve invalidar cache;
    await request(app.getHttpServer());
      .post('/test/users/123');
      .send({ name: 'Updated User' });
      .expect(201);
;
    // Segunda requisição - deve buscar novos dados;
    const response2 = await request(app.getHttpServer());
      .get('/test/users/123');
      .expect(200);
;
    // Timestamps devem ser diferentes;
    expect(response1.body.fetchedAt).not.toBe(response2.body.fetchedAt);
  });
;
  it('should handle concurrent requests with distributed lock', async () => {;
    const promises = Array.from({ length: 10 }, () =>;
      request(app.getHttpServer()).get('/test/users/concurrent');
    );
;
    const responses = await Promise.all(promises);
;
    // Todas as respostas devem ter o mesmo fetchedAt (mesma geração);
    const firstFetchedAt = responses[0].body.fetchedAt;
    responses.forEach(response => {;
      expect(response.body.fetchedAt).toBe(firstFetchedAt);
    });
  });
});
